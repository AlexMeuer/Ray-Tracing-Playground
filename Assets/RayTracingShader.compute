#pragma kernel CSMain

RWTexture2D<float4> result;
float4x4 camera_to_world;
float4x4 camera_inverse_projection;
Texture2D<float4> skybox_texture;
SamplerState sampler_skybox_texture;
float2 pixel_offset;
int ray_bounces;
float4 directional_light;
float3 specular_mul;
float3 albedo_mul;
static const float pi = 3.14159265f;

struct ray
{
    float3 origin;
    float3 direction;
    float3 energy;
};

struct ray_hit
{
    float3 position;
    float distance;
    float3 normal;
};

ray create_ray(const float3 origin, const float3 direction)
{
    ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.energy = float3(1.0f, 1.0f, 1.0f);
    return ray;
}

ray_hit create_ray_hit()
{
    ray_hit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    return hit;
}

ray create_camera_ray(float2 uv)
{
    // Transform the camera origin to world space
    const float3 origin = mul(camera_to_world, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(camera_inverse_projection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(camera_to_world, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return create_ray(origin, direction);
}

void intersect_ground_plane(ray ray, inout ray_hit best_hit)
{
    // Calculate distance along the ray where the ground plane intersected.
    const float t = -ray.origin.y / ray.direction.y;
    if (t > 0 && t < best_hit.distance)
    {
        best_hit.distance = t;
        best_hit.position = ray.origin + t * ray.direction;
        best_hit.normal = float3(0.0f, 1.0f, 0.0f);
    }
}

void intersect_sphere(ray ray, inout ray_hit best_hit, float4 sphere)
{
    // Calculate distance along the ray where the sphere is intersected
    const float3 d = ray.origin - sphere.xyz;
    const float p1 = -dot(ray.direction, d);
    const float p2_sqr = p1 * p1 - dot(d, d) + sphere.w * sphere.w;
    if (p2_sqr < 0)
        return;
    float p2 = sqrt(p2_sqr);
    float t = p1 - p2 > 0 ? p1 - p2 : p1 + p2;
    if (t > 0 && t < best_hit.distance)
    {
        best_hit.distance = t;
        best_hit.position = ray.origin + t * ray.direction;
        best_hit.normal = normalize(best_hit.position - sphere.xyz);
    }
}

ray_hit trace(const ray ray)
{
    ray_hit best_hit = create_ray_hit();
    intersect_ground_plane(ray, best_hit);
    for (int i = -5; i <= 5; i++)
    {
        for (int j = 0; j <= 10; j++)
        {
            intersect_sphere(ray, best_hit, float4(i * 3, 1, j * 3, 1.0f));
        }
    }
    intersect_sphere(ray, best_hit, float4(0, 3.0f, 0, 1.0f));
    return best_hit;
}

float3 shade(inout ray main_ray, const ray_hit hit)
{
    if (hit.distance < 1.#INF)
    {
        // Reflect the ray and multiply energy with specular reflection
        main_ray.origin = hit.position + hit.normal * 0.001f;
        main_ray.direction = reflect(main_ray.direction, hit.normal);
        main_ray.energy *= specular_mul;
        
        // Shadow test ray
        const ray shadow_ray = create_ray(hit.position + hit.normal * 0.001f, -1 * directional_light.xyz);
        const ray_hit shadow_hit = trace(shadow_ray);
        if (shadow_hit.distance != 1.#INF)
        {
            return float3(0.0f, 0.0f, 0.0f);
        }

        // Diffuse
        return saturate(dot(hit.normal, directional_light.xyz) * -1) * directional_light.w * albedo_mul;
    } else
    {
        // Erase the ray's energy - the sky doesn't reflect
        main_ray.energy = 0.0f;
        
        // Sample the skybox and write it
        float theta = acos(main_ray.direction.y) / -pi;
        float phi = atan2(main_ray.direction.x, -main_ray.direction.z) / -pi * 0.5f;
        return skybox_texture.SampleLevel(sampler_skybox_texture, float2(phi, theta), 0).xyz;
    }
}

[numthreads(8,8,1)]
// ReSharper disable once CppInconsistentNaming
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    result.GetDimensions(width, height);

    // Transform pixel to [-1,1] range
    const float2 uv = float2((id.xy + pixel_offset) / float2(width, height) * 2.0f - 1.0f);

    // Get a ray for the UVs
    ray ray = create_camera_ray(uv);

    // Trace and shade
    float3 col = float3(0, 0, 0);
    for (int i = 0; i < ray_bounces; i++)
    {
        ray_hit hit = trace(ray);
        col += ray.energy * shade(ray, hit);

        if (!any(ray.energy))
            break;
    }
    result[id.xy] = float4(col, 1);
}